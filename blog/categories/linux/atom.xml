<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | 但行好事，莫问前程]]></title>
  <link href="http://caiknife.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://caiknife.github.io/"/>
  <updated>2018-06-24T04:22:41+08:00</updated>
  <id>http://caiknife.github.io/</id>
  <author>
    <name><![CDATA[CaiKnife]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux 查看系统性能和配置的常用命令整理]]></title>
    <link href="http://caiknife.github.io/blog/2014/03/07/linux-commands/"/>
    <updated>2014-03-07T11:53:02+08:00</updated>
    <id>http://caiknife.github.io/blog/2014/03/07/linux-commands</id>
    <content type="html"><![CDATA[<p>常用 Linux 命令存档。</p>

<!-- more -->


<p>查看CPU信息（型号）</p>

<p>``` bash
$ cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</p>

<pre><code>8  Intel(R) Xeon(R) CPU            E5410   @ 2.33GHz
</code></pre>

<p>```</p>

<p>（看到有8个逻辑CPU, 也知道了CPU型号）</p>

<p>``` bash
$ cat /proc/cpuinfo | grep physical | uniq -c</p>

<pre><code>4 physical id      : 0
4 physical id      : 1
</code></pre>

<p>```</p>

<p>（说明实际上是两颗4核的CPU）</p>

<p>``` bash
$ getconf LONG_BIT</p>

<pre><code>32
</code></pre>

<p>```</p>

<p>（说明当前CPU运行在32bit模式下, 但不代表CPU不支持64bit）</p>

<p><code>bash
$ cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l
   8
</code></p>

<p>（结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit）</p>

<p>再完整看cpu详细信息, 不过大部分我们都不关心而已。</p>

<p><code>bash
$ dmidecode | grep -A81 'Processor Information'
</code></p>

<p>查看主板型号：</p>

<p><code>bash
$ dmidecode | grep -A16 "System Information$"
</code></p>

<p>内存槽及内存条：</p>

<p><code>bash
$ dmidecode | grep -A16 "Memory Device$"
</code></p>

<p>查看内存信息
<code>bash
$ cat /proc/meminfo
</code></p>

<p>``` bash
$ uname -a</p>

<pre><code>Linux euis1 2.6.9-55.ELsmp #1 SMP Fri Apr 20 17:03:35 EDT 2007 i686 i686 i386 GNU/Linux
</code></pre>

<p>```</p>

<p>（查看当前操作系统内核信息）</p>

<p><code>bash
$ hostname      # 主机名
$ lspci -tv     # 列出所有pci设备
$ lsusb -tv     # 列出所有use设备
</code></p>

<p>``` bash
$ cat /etc/issue | grep Linux</p>

<pre><code>Red Hat Enterprise Linux AS release 4 (Nahant Update 5)
</code></pre>

<p>```</p>

<p>（查看当前操作系统发行版信息）</p>

<p>查看机器型号：</p>

<p><code>bash
$ dmidecode | grep "Product Name"  
</code></p>

<p>查看网卡信息：
<code>bash
$ dmesg | grep -i eth
$ mii-tool
</code></p>

<p>硬盘：
<code>bash
$ fdisk -l
$ smartctl -a /dev/sda
</code></p>

<p><code>bash
$ hostname                      # 查看计算机名
$ lspci -tv                     # 列出所有PCI设备
$ lsusb -tv                     # 列出所有USB设备
$ lsmod                         # 列出加载的内核模块
$ env                           # 查看环境变量资源
$ free -m                       # 查看内存使用量和交换区使用量
$ df -h                         # 查看各分区使用情况
$ du -sh                        # 查看指定目录的大小
$ grep MemTotal /proc/meminfo   # 查看内存总量
$ grep MemFree /proc/meminfo    # 查看空闲内存量
$ uptime                        # 查看系统运行时间、用户数、负载
$ cat /proc/loadavg             # 查看系统负载磁盘和分区
$ mount | column -t             # 查看挂接的分区状态
$ fdisk -l                      # 查看所有分区
$ swapon -s                     # 查看所有交换分区
$ hdparm -i /dev/hda            # 查看磁盘参数(仅适用于IDE设备)
$ dmesg | grep IDE              # 查看启动时IDE设备检测状况网络
$ ifconfig                      # 查看所有网络接口的属性
$ iptables -L                   # 查看防火墙设置
$ route -n                      # 查看路由表
$ netstat -lntp                 # 查看所有监听端口
$ netstat -antp                 # 查看所有已经建立的连接
$ netstat -s                    # 查看网络统计信息进程
$ ps -ef                        # 查看所有进程
$ top                           # 实时显示进程状态用户
$ w                             # 查看活动用户
$ id                            # 查看指定用户信息
$ last                          # 查看用户登录日志
$ cut -d: -f1 /etc/passwd       # 查看系统所有用户
$ cut -d: -f1 /etc/group        # 查看系统所有组
$ crontab -l                    # 查看当前用户的计划任务服务
$ chkconfig –list               # 列出所有系统服务
$ chkconfig –list | grep on     # 列出所有启动的系统服务程序
$ rpm -qa                       # 查看所有安装的软件包
$ cat /proc/cpuinfo             # 查看CPU相关参数
$ cat /proc/partitions          # 查看硬盘和分区
$ cat /proc/meminfo             # 查看内存信息
$ cat /proc/version             # 查看版本，类似uname -r
$ cat /proc/ioports             # 查看设备io端口
$ cat /proc/interrupts          # 查看中断
$ cat /proc/pci                 # 查看pci设备的信息
$ cat /proc/swaps               # 查看所有swap分区的信息
</code></p>

<p>Have a nice day！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[越过长城，呼吸自由]]></title>
    <link href="http://caiknife.github.io/blog/2014/03/03/cross-the-great-fire-wall/"/>
    <updated>2014-03-03T11:23:38+08:00</updated>
    <id>http://caiknife.github.io/blog/2014/03/03/cross-the-great-fire-wall</id>
    <content type="html"><![CDATA[<p>最近 GFW 似乎又升级了，有几天上 GitHub 的时候很不方便；而 Chrome 的 Google 账户登录更是从来没成功过。在公司的时候，由于走的是国外的线路，接上网线就相当于直接翻墙了，可是回到家里，我还是需要登录 Google 账户的。怎么办？</p>

<p>翻墙工具找起来！</p>

<p>前段时间用了 GoAgent 来翻墙，今天来做个记录。</p>

<!-- more -->


<p>项目主页在这里：<a href="https://code.google.com/p/goagent/">https://code.google.com/p/goagent/</a> 。</p>

<p>最新的源代码可以在这里 <a href="https://github.com/goagent/goagent/">https://github.com/goagent/goagent/</a> 找到。</p>

<p>安装方法和配置方法都有图文介绍，挺方便的。翻墙之后速度挺快，一般的浏览没啥问题，不过如果要是看 YouTube 之类的网站的话就有点捉襟见肘了。</p>

<p>虽然身在长城内，但是心还是向往自由的。</p>

<p>Have a nice day！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一句话 Shell 脚本（3）]]></title>
    <link href="http://caiknife.github.io/blog/2014/02/26/happy-shell-script/"/>
    <updated>2014-02-26T10:00:43+08:00</updated>
    <id>http://caiknife.github.io/blog/2014/02/26/happy-shell-script</id>
    <content type="html"><![CDATA[<p>CakePHP 会在自己的项目文件夹的 <code>app/tmp</code> 下建立缓存文件，用来保存数据库表结构。在开启 debug 的情况下，每次发起请求后都会刷新缓存，但是在生产环境下，一般都是关闭了 debug 的，如果某次功能升级修改了表结构的话，缓存并不会主动更新，如此一来就会产生 InternalError 。</p>

<p>看来还是要写个脚本来手动删除这些缓存文件。</p>

<!-- more -->


<p>先看看缓存目录结构是什么样的：</p>

<p>``` bash</p>

<blockquote><p>tree
.
├── cache
│   ├── cake_toolbar_cache19c90b767c0870ceefeb6659d993da93
│   ├── models
│   │   ├── ccqo_cake_model_default_ccqo_accounts
│   │   ├── ccqo_cake_model_default_ccqo_articles
│   │   ├── ccqo_cake_model_default_ccqo_list
│   │   ├── ccqo_cake_model_default_ccqo_train_divisions
│   │   ├── ccqo_cake_model_default_ccqo_trainees
│   │   ├── ccqo_cake_model_default_ccqo_trainers
│   │   └── ccqo_cake_model_default_ccqo_train_infos
│   └── persistent
│       ├── ccqo_cake_core_cake_zh-cn
│       ├── ccqo_cake_core_debug_kit_zh-cn
│       ├── ccqo_cake_core_file_map
│       └── ccqo_cake_core_method_cache
└── logs
```</p></blockquote>

<p>要删除的是缓存文件，目录不用删除。 OK ，那么就写个脚本一次性全部搞定好了。</p>

<p>先想到的是用 <code>find</code> 命令配合管道符来用：</p>

<p>``` bash</p>

<blockquote><p>find . -type f | xargs rm -f
```</p></blockquote>

<p>结果报了权限错误：</p>

<p>``` bash</p>

<blockquote><p>find . -type f | xargs rm -f
rm: 无法删除"./cache/persistent/ccqo_cake_core_cake_zh-cn": 权限不够
rm: 无法删除"./cache/persistent/ccqo_cake_core_file_map": 权限不够
rm: 无法删除"./cache/persistent/ccqo_cake_core_debug_kit_zh-cn": 权限不够
rm: 无法删除"./cache/persistent/ccqo_cake_core_method_cache": 权限不够
rm: 无法删除"./cache/models/ccqo_cake_model_default_ccqo_list": 权限不够
rm: 无法删除"./cache/models/ccqo_cake_model_default_ccqo_train_divisions": 权限不够
rm: 无法删除"./cache/models/ccqo_cake_model_default_ccqo_trainers": 权限不够
rm: 无法删除"./cache/models/ccqo_cake_model_default_ccqo_articles": 权限不够
rm: 无法删除"./cache/models/ccqo_cake_model_default_ccqo_train_infos": 权限不够
rm: 无法删除"./cache/models/ccqo_cake_model_default_ccqo_trainees": 权限不够
rm: 无法删除"./cache/models/ccqo_cake_model_default_ccqo_accounts": 权限不够
```</p></blockquote>

<p>这些文件是由 <code>www-data</code> 帐号生成的，所以我自然不能删除，所以加上 <code>sudo</code> 再删除吧。</p>

<p>几分钟之后又想了想，其实不用管道符，完全可以用 <code>find</code> 自己就可以完成了：</p>

<p>``` bash</p>

<blockquote><p>find . -type f -exec sudo rm -f {} +
```</p></blockquote>

<p>打完收工！</p>

<p>最近越来越感觉随着年纪的增长，接触的事情越来越多，记忆力没有以前好了。高中时代特别自豪地过目不忘的本事也指望不上了，看来还是好记性不如烂笔头，得养成一个良好的记录和总结的习惯，才会对将来的工作有所帮助。</p>

<p>Have a nice day！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 下 Gnome 终端出现假透明]]></title>
    <link href="http://caiknife.github.io/blog/2014/02/11/ubuntu-gnome-terminal-no-transparency/"/>
    <updated>2014-02-11T14:28:56+08:00</updated>
    <id>http://caiknife.github.io/blog/2014/02/11/ubuntu-gnome-terminal-no-transparency</id>
    <content type="html"><![CDATA[<p>某次更新过 Ubuntu 之后，Gnome 终端就从真透明变成了假透明，使用起来非常不方便。</p>

<p>今天，从 <a href="http://askubuntu.com/questions/266533/gnome-terminal-transparency-with-gnome-classic-no-effects">http://askubuntu.com/questions/266533/gnome-terminal-transparency-with-gnome-classic-no-effects</a> 找到了解决问题的方法。</p>

<!-- more -->


<p>按照图中的方法修改一下配置，终端又变回真透明了。</p>

<p><a href="/downloads/image/terminal/config.png" title="Config " class="fancybox"><img src="/downloads/image/terminal/config.png" alt="Config " /></a></p>

<p>下面是之前的假透明：</p>

<p><a href="/downloads/image/terminal/faketrans.png" title="Fake Transparency " class="fancybox"><img src="/downloads/image/terminal/faketrans.png" alt="Fake Transparency " /></a></p>

<p>修改之后回到了真透明：</p>

<p><a href="/downloads/image/terminal/truetrans.png" title="True Transparency " class="fancybox"><img src="/downloads/image/terminal/truetrans.png" alt="True Transparency " /></a></p>

<p>Have a nice day！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Vundle 来管理 vim 插件]]></title>
    <link href="http://caiknife.github.io/blog/2013/12/05/using-vundle-for-vim-plugins/"/>
    <updated>2013-12-05T14:00:23+08:00</updated>
    <id>http://caiknife.github.io/blog/2013/12/05/using-vundle-for-vim-plugins</id>
    <content type="html"><![CDATA[<p>刚用 <code>Pathogen</code> 配置好了 vim 的插件，马上就去看了 <code>Vundle</code> ，了解之后顿时觉得——哇塞这玩意儿太给力了！</p>

<p>比起 <code>Pathogen</code> 用 git submodule 来手动管理插件，<code>Vundle</code> 则是使用 git 做了完全自动化的操作，只需要很少的配置就能管理 vim 插件了。</p>

<!-- more -->


<h2>安装 Vundle</h2>

<p>使用下面的命令来安装 <code>Vundle</code> ，并把主目录下面的 <code>~/.vimrc</code> 文件指向 <code>～/.vim/.vimrc</code> ：</p>

<p><code>bash
$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
$ ln -s ～/.vim/.vimrc ~/.vimrc
</code></p>

<h2>配置 .vimrc</h2>

<p>在 <code>Vundle</code> 的官方网站 <a href="https://github.com/gmarik/vundle">https://github.com/gmarik/vundle</a> 上有默认的配置，只需要做一下修改就行了：</p>

<p>``` vim
set nocompatible              &ldquo; be iMproved
filetype off                  &rdquo; required!</p>

<p>set rtp+=~/.vim/bundle/vundle/
call vundle#rc()</p>

<p>&ldquo; let Vundle manage Vundle
&rdquo; required!
Bundle &lsquo;gmarik/vundle&rsquo;</p>

<p>&ldquo; My bundles here:
&rdquo;
&ldquo; original repos on GitHub
Bundle &lsquo;tpope/vim-fugitive&rsquo;
Bundle &lsquo;Lokaltog/vim-powerline&rsquo;
Bundle &lsquo;Shougo/neocomplcache.vim&rsquo;
Bundle &lsquo;rstacruz/sparkup&rsquo;, {&lsquo;rtp&rsquo;: &lsquo;vim/&rsquo;}
Bundle &lsquo;tpope/vim-rails.git&rsquo;
&rdquo; vim-scripts repos
Bundle &lsquo;L9&rsquo;
Bundle &lsquo;FuzzyFinder&rsquo;</p>

<p>filetype plugin indent on     &ldquo; required!
&rdquo;
&ldquo; Brief help
&rdquo; :BundleList          &ndash; list configured bundles
&ldquo; :BundleInstall(!)    &ndash; install (update) bundles
&rdquo; :BundleSearch(!) foo &ndash; search (or refresh cache first) for foo
&ldquo; :BundleClean(!)      &ndash; confirm (or auto-approve) removal of unused bundles
&rdquo;
&ldquo; see :h vundle for more details or wiki for FAQ
&rdquo; NOTE: comments after Bundle commands are not allowed.
```</p>

<h2>安装插件</h2>

<p>配置完 <code>.vimrc</code> 之后，推出 vim 并重新进入，在命令模式下输入 <code>:BundleInstall</code> ，系统就会自动开始安装插件。在 <code>bundle</code> 目录下生成下面的目录结构：</p>

<p>``` bash
$ tree -L 1
.
├── FuzzyFinder
├── L9
├── neocomplcache.vim
├── sparkup
├── vim-fugitive
├── vim-powerline
├── vim-rails
└── vundle</p>

<p>8 directories, 0 files
```</p>

<p>别的插件我用不上，只用到了 <code>neocomplcache.vim</code> 和 <code>vim-powerline</code> 这两个。配置文件内容和上一篇文章里的提到的一样：</p>

<h2>更新插件</h2>

<p>使用 <code>Vundle</code> 更新插件非常简单，只用打开一个 vim ，然后输入命令 <code>:BundleInstall!</code> 。</p>

<h2>删除插件</h2>

<p>使用 <code>Vundle</code> 卸载插件也很简单，只需在 .vimrc 去掉绑定插件的命令及插件的配置（注释掉即可，以免以后会使用），假如需要卸载 <code>vim-powerline</code> 这个插件，首先在 .vimrc 中注释掉以下内容：</p>

<p>``` vim
Bundle &lsquo;Lokaltog/vim-powerline&rsquo;</p>

<p>set laststatus=2
set t_Co=256
let g:Powline_symbols=&lsquo;fancy&rsquo;
```</p>

<p>保存 .vimrc 文件，重新打开一个 vim ，输入命令 <code>:BundleClean</code> ，打开 <code>~/.vim/bundle</code> 已经看不到插件 <code>vim-powerline</code> 的相关文件。</p>

<p>Have a nice day！</p>
]]></content>
  </entry>
  
</feed>
