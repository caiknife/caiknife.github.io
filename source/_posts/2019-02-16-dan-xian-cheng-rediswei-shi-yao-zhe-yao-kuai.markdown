---
layout: post
title: "单线程redis为什么这么快？"
date: 2019-02-16 15:47:07 +0800
comments: true
categories: redis 缓存
---
redis 采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由 C 语言编写，官方提供的数据是可以达到 100000+ 的 QPS。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差。

有兴趣的可以参考官方的基准程序测试《How fast is Redis？》<https://redis.io/topics/benchmarks>

{% fancybox /downloads/image/redis/benchmark.png redis benchmark %}

<!-- more -->

Redis快的主要原因是：

> 完全基于内存
 
> 数据结构简单，对数据操作也简单
 
> 使用多路 I/O 复用模型

下面主要围绕第三点采用多路 I/O 复用技术来展开。

多路 I/O 复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了 redis 具有很高的吞吐量。

和 Memcached 不同，redis 并没有直接使用 libevent，而是自己完成了一个非常轻量级的对 select、epoll、evport、kqueue 这些通用的接口的实现。在不同的系统调用选用适合的接口，linux 下默认是 epoll。因为 libevent 比较重更通用代码量也就很庞大，拥有很多 redis 用不上的功能，redis为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。

至于为什么 redis 要使用单进程单线程：

> 代码更清晰，处理逻辑更简单

> 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗

> 不存在多进程或者多线程导致的切换而消耗CPU

至于弊端，那也是显而易见的——无法发挥多核 CPU 性能，不过可以通过在单机开多个 redis 实例来完善。
