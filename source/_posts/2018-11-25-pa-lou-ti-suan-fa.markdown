---
layout: post
title: "算法题：爬楼梯算法"
date: 2018-11-25 18:16:40 +0800
comments: true
categories: 算法 编程 实战 递归
---
有这样一个题目：应该是大学时代的经典算法题了——小孩上楼梯。

> 有个小孩正在上楼梯，楼梯有s阶台阶，小孩一次可以上1阶或2阶。实现一个算法，计算小孩有多少种上楼梯的方式。输入n，返回一个整数。

稍微想了一下，这个题目可以用递归来解决。根据题目的规则，最后一步只有两种走法：要么走1阶，要么走2阶。所以可以得出这么一个递归公式：`f(s) = f(s-1) + f(s-2)`。好像就是一个斐波那契数列公式？

<!-- more -->

这个问题的边界值就是在只有1阶的情况下，只有1种方式(1)；在只有2阶的情况下，有两种方式(1,1)、(2)。

编写程序如下：

{% include_code stair/stair.go %}

使用正常的递归，在递归层数过多的情况下，可能会有stack overflow的风险，所以可以改写为用循环处理的方式：

{% include_code stair/stair_with_loop.go %}

将循环中使用到的变量提取出来作为函数的参数使用，就成了尾递归。在方法最后被调用时，线程栈里面的临时变量与参数此时已经没任何用了，可以被GC回收，所以理论上就是同上面的循环方法是一致的，无论有多深，都不会发生内存异常。

{% include_code stair/stair_with_tail.go %}

下面扩展一下思路：

> 这小屁孩的老师作业留少了，闲着没事爬楼梯，楼梯有s阶台阶(steps)，小孩一次可以上m阶（maxStep）。计算小孩有多少种上楼梯的方式。输入s,m，返回一个整数。

一样分析可以得到公式：`f(s) = f(s-1) + f(s-2) + ... + f(s-m)`。

参照上例思路，我们可以在递归里分为两大部分，一部分是steps > maxStep时，参照f(s,m) = f(s-1) + f(s-2) + f(s-3) + ... + f(s-m)进行累加。

我们现在看steps <= maxStep时，怎么给出类似上例里f(2)，f(3)的返回值。其实，上例中的f(3)，就是台阶一共3级，最大可以跨2步的值，即f(2) 就是f(2,2)，f(3)就是f(3,2)。分析一下就得出下面的图解：

{% fancybox /downloads/image/go/stair.jpg 爬楼梯算法 %}

根据以上图解，分析如下：

```
steps > maxStep 时，f(s,m) = f(s-1) + f(s-2) + f(s-3) + ··· + f(s-m);
steps <= maxStep时，f(s,s) = f(s,s-1) +1;
steps = 1时，return 1;
steps = 0时，return 0;
```

编码如下：

{% include_code stair/stair_with_s_m.go %}

打完收工。